#'******************************************************************************
#' Description: Cost functions for spring phenology models, used to optimize 
#' and estimate parameters for models. Check `Code/hlp_spring_pheno_models.R` 
#' for more information.
#'******************************************************************************



#' Root Mean Squared Error (RMSE) cost function
#' @param par The model paramter vector.
#' @param model The model function or string.
#' @param data The data needed to fit the model.
#' @return The RMSE value calculated on current data and parameters
#' @export
CostRMSE <- function(par, model, data, ...) {
    est <- do.call(model, list(par = par, data = data, ...))
    if (any(is.na(est))) {
        return(9999)
    } else {
        # return the RMSE between the validation data and
        # the output of the model
        return(sqrt(mean((data$transition_dates - est)^2, na.rm = TRUE)))
    }
}


#' Log likelihood cost function for model optimization
#'
#' The function is aimed to be maximized, to use it with optimizers which
#' minimize cost functions wrap the function as such:
#' `cost = function(...){abs(likelihood(...))}`
#'
#' @param par a vector of parameter values, this is functions specific
#' @param data nested data structure with validation data as returned
#' by format_phenocam() or format_pep725(), or your own dataset adhering
#' to the same data structure.
#' @param model the model name to be used in optimizing the model
#' @param ... extra arguments to pass to the function
#' @return the RMSE comparing observed and estimated values
#' @keywords phenology, model, optimization, cost function
#' @export
#' @examples
#'
#' # The cost function returns the rmse between the
#' # true values and those generated by the model given a
#' # parameterset par.
#' \dontrun{
#' cost_value = likelihood(par, data, model="TTs")
#' }

likelihood <- function(
  par,
  data,
  model,
  ...
  ) {

  # model parameters
  model_par <- par[1:(length(par)) - 1]

  # split out sd range parameter
  sd_range <- par[length(par)]

  # run model
  observed <- data$transition_dates
  predicted <- do.call(
    model,
    list(
      data = data,
      par = model_par
      )
    )

  # get residuals
  residuals <- predicted - observed

  # singlelikelihood
  singlelikelihoods <- stats::dnorm(
      residuals,
      sd = sd_range,
      log = TRUE
      )

  return(sum(singlelikelihoods, na.rm = TRUE))
}
